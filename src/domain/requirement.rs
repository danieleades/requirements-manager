use std::collections::BTreeSet;

use borsh::BorshSerialize;
use chrono::{DateTime, Utc};
use sha2::{Digest, Sha256};

use crate::domain::Hrid;

pub type Fingerprint = String;

/// A requirement is a document used to describe a system.
///
/// It can represent a user requirement, a specification, etc.
/// Requirements can have dependencies between them, such that one requirement
/// satisfies, fulfils, verifies (etc.) another requirement.
#[derive(Debug, Clone, PartialEq)]
pub struct Requirement {
    content: Content,
    created: DateTime<Utc>,
}

/// The semantically important content of the requirement.
///
/// This contributes to the 'fingerprint' of the requirement
#[derive(Debug, BorshSerialize, Clone, PartialEq, Default)]
struct Content {
    content: String,
    tags: BTreeSet<String>,
}

impl Content {
    fn fingerprint(&self) -> String {
        // encode using [borsh](https://borsh.io/)
        let encoded = borsh::to_vec(self).expect("this should never fail");

        // generate a SHA256 hash
        let hash = Sha256::digest(encoded);

        // Convert to hex string
        format!("{hash:x}")
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Parent {
    pub hrid: Hrid,
    pub fingerprint: String,
}

impl Default for Requirement {
    fn default() -> Self {
        Self::new(String::new())
    }
}

impl Requirement {
    /// Construct a new [`Requirement`] from a human-readable ID and its
    /// content.
    ///
    /// A new UUID is automatically generated.
    #[must_use]
    pub fn new(content: String) -> Self {
        let content = Content {
            content,
            tags: BTreeSet::default(),
        };

        Self {
            content,
            created: Utc::now(),
        }
    }

    /// The body of the requirement.
    ///
    /// This should be a markdown document.
    #[must_use]
    pub fn content(&self) -> &str {
        &self.content.content
    }

    /// The tags on the requirement
    #[must_use]
    pub const fn tags(&self) -> &BTreeSet<String> {
        &self.content.tags
    }

    /// Set the tags on the requirement.
    ///
    /// this replaces any existing tags.
    pub fn set_tags(&mut self, tags: BTreeSet<String>) {
        self.content.tags = tags;
    }

    /// Add a tag to the requirement.
    ///
    /// returns 'true' if a new tag was inserted, or 'false' if it was already
    /// present.
    pub fn add_tag(&mut self, tag: String) -> bool {
        self.content.tags.insert(tag)
    }

    /// When the requirement was first created
    #[must_use]
    pub const fn created(&self) -> DateTime<Utc> {
        self.created
    }

    /// Returns a value generated by hashing the content of the Requirement.
    ///
    /// Any change to the requirement will change the fingerprint. This is used
    /// to determine when links are 'suspect'. Meaning that because a
    /// requirement has been modified, related or dependent requirements
    /// also need to be reviewed to ensure consistency.
    #[must_use]
    pub fn fingerprint(&self) -> String {
        self.content.fingerprint()
    }
}

#[cfg(test)]
mod tests {
    use std::collections::BTreeSet;

    use super::Content;

    #[test]
    fn fingerprint_does_not_panic() {
        let content = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        content.fingerprint();
    }

    #[test]
    fn fingerprint_is_stable_with_tag_order() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag2".to_string(), "tag1".to_string()].into(),
        };
        assert_eq!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn tags_affect_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string()].into(),
        };
        let content2 = Content {
            content: "Some string".to_string(),
            tags: ["tag1".to_string(), "tag2".to_string()].into(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }

    #[test]
    fn content_affects_fingerprint() {
        let content1 = Content {
            content: "Some string".to_string(),
            tags: BTreeSet::default(),
        };
        let content2 = Content {
            content: "Other string".to_string(),
            tags: BTreeSet::default(),
        };
        assert_ne!(content1.fingerprint(), content2.fingerprint());
    }
}
