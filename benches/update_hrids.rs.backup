//! This bench test simulates updating the human-readable IDs (HRIDs) in parent
//! links in a large directory of requirements.

#![allow(missing_docs)]

use std::{path::PathBuf, str::FromStr};

use criterion::{criterion_group, criterion_main, Criterion};
use non_empty_string::NonEmptyString;
use requiem::{Directory, Hrid, Requirement};
use tempfile::TempDir;

/// Generates a large number of interlinked documents
fn preseed_directory(path: PathBuf) {
    let mut directory = Directory::load(path).unwrap();
    for i in 1..=99 {
        directory
            .add(NonEmptyString::from_str("USR").unwrap(), Requirement::default())
            .unwrap();
        directory
            .add(NonEmptyString::from_str("SYS").unwrap(), Requirement::default())
            .unwrap();
        let mut requirement = directory
            .link(
                &Hrid::new(NonEmptyString::from_str("SYS").unwrap(), i),
                &Hrid::new(NonEmptyString::from_str("USR").unwrap(), i),
            )
            .unwrap();
        requirement.parents_mut().next().unwrap().1.hrid = Hrid::try_from("WRONG-001").unwrap();
    }
}

use criterion::BatchSize;

fn update_hrids(c: &mut Criterion) {
    c.bench_function("update hrids", |b| {
        b.iter_batched(
            || {
                // Setup: create directory with broken HRIDs
                let tmp_dir = TempDir::new().unwrap();
                preseed_directory(tmp_dir.path().to_path_buf());
                tmp_dir
            },
            |tmp_dir| {
                Directory::load(tmp_dir.path().to_path_buf())
                    .unwrap()
                    .update_hrids()
                    .unwrap();
            },
            BatchSize::SmallInput,
        );
    });
}

criterion_group!(benches, update_hrids);
criterion_main!(benches);
